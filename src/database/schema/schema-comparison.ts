import type { TableSchema, ColumnDefinition, ViewSchema, TriggerSchema } from "../base-controller";

export type ChangeType = "CREATE" | "DROP" | "ALTER" | "RENAME" | "NONE";

export interface ColumnDiff {
  columnName: string;
  changeType: ChangeType;
  oldColumn?: ColumnDefinition;
  newColumn?: ColumnDefinition;
  differences?: string[]; // List of property names that changed
}

export interface IndexDiff {
  indexName: string;
  changeType: ChangeType;
  oldIndex?: { name: string; columns: string[]; unique?: boolean };
  newIndex?: { name: string; columns: string[]; unique?: boolean };
}

export interface TableDiff {
  tableName: string;
  changeType: ChangeType;
  oldSchema?: TableSchema;
  newSchema?: TableSchema;
  columnDiffs: ColumnDiff[];
  indexDiffs: IndexDiff[];
  newName?: string; // For RENAME
}

export interface ViewDiff {
  viewName: string;
  changeType: ChangeType;
  oldView?: ViewSchema;
  newView?: ViewSchema;
}

export interface TriggerDiff {
  triggerName: string;
  changeType: ChangeType;
  oldTrigger?: TriggerSchema;
  newTrigger?: TriggerSchema;
}

export interface SchemaDiff {
  tableDiffs: TableDiff[];
  viewDiffs: ViewDiff[];
  triggerDiffs: TriggerDiff[];
}

export interface CompareOptions {
    renames?: {
        tables?: Record<string, string>; // oldName -> newName
        columns?: Record<string, Record<string, string>>; // tableName -> { oldCol -> newCol }
    };
}

export class SchemaComparator {


  static compareSchemas(
      currentSchemas: TableSchema[],
      targetSchemas: TableSchema[],
      options?: CompareOptions,
      currentViews: ViewSchema[] = [],
      targetViews: ViewSchema[] = [],
      currentTriggers: TriggerSchema[] = [],
      targetTriggers: TriggerSchema[] = []
  ): SchemaDiff {
      const tableDiffs: TableDiff[] = [];
      const viewDiffs: ViewDiff[] = [];
      const triggerDiffs: TriggerDiff[] = [];

      const renameMap = options?.renames?.tables || {};
      // Reverse map for easier lookup: newName -> oldName
      const reverseRenameMap = Object.entries(renameMap).reduce((acc, [oldName, newName]) => {
          acc[newName] = oldName;
          return acc;
      }, {} as Record<string, string>);

      // 1. Check Target Tables (Create, Alter, or Renamed-to)
      for (const targetTable of targetSchemas) {
          let currentTable: TableSchema | undefined;
          
          // Check if this is a renamed table
          const oldName = reverseRenameMap[targetTable.tableName];
          if (oldName) {
              currentTable = currentSchemas.find(t => t.tableName === oldName);
          } else {
              currentTable = currentSchemas.find(t => t.tableName === targetTable.tableName);
          }

          if (!currentTable) {
              tableDiffs.push({
                  tableName: targetTable.tableName,
                  changeType: "CREATE",
                  newSchema: targetTable,
                  columnDiffs: [],
                  indexDiffs: []
              });
          } else {
              // It exists (or was renamed from existing)
              const diff = this.compareTable(currentTable, targetTable, options?.renames?.columns?.[currentTable.tableName]);
              
              const isRename = oldName && oldName !== targetTable.tableName;
              
              if (
                  diff.changeType !== "NONE" ||
                  diff.columnDiffs.some(c => c.changeType !== "NONE") || // check deeply
                  diff.indexDiffs.length > 0 ||
                  isRename
              ) {
                  if (isRename) {
                      diff.changeType = "RENAME"; // Or combine with ALTER? RENAME is basically a Table Action
                      diff.newName = targetTable.tableName;
                      diff.tableName = oldName!; // Report diff against OLD name usually, or we need to be careful
                      // Actually, let's stick to reporting diffs generated by comparator, 
                      // but modify the top-level tableDiff to indicate rename 
                  }
                  
                  // If we renamed, we might want to ensure changeType is at least RENAME
                  if (diff.changeType === "NONE" && isRename) diff.changeType = "RENAME";
                   else if (isRename) {
                       // It has structural changes AND is renamed. 
                       // We can handle this by treating RENAME as top priority or handling it in generator
                       // The generator will see 'RENAME' and 'newName'. 
                       // If columnDiffs exist, they should be applied AFTER rename? 
                       // Standard SQL: RENAME TO x; ALTER TABLE x ...;
                   }

                  tableDiffs.push(diff);
              }
          }
      }

      // 2. Check Current Tables (Drop)
      for (const currentTable of currentSchemas) {
          // If it was renamed to something, it's not dropped
          if (renameMap[currentTable.tableName]) continue;
          
          // If it exists in target (exact match), it's handled above
          const targetTable = targetSchemas.find(t => t.tableName === currentTable.tableName);
          
          if (!targetTable) {
              tableDiffs.push({
                  tableName: currentTable.tableName,
                  changeType: "DROP",
                  oldSchema: currentTable,
                  columnDiffs: [],
                  indexDiffs: []
              });
          }
      }

      // 3. Views
      // Compare Views (Simple definitions check)
      const currentViewMap = new Map(currentViews.map(v => [v.name, v]));
      const targetViewMap = new Map(targetViews.map(v => [v.name, v]));

      for (const targetView of targetViews) {
          const currentView = currentViewMap.get(targetView.name);
          if (!currentView) {
              viewDiffs.push({ viewName: targetView.name, changeType: "CREATE", newView: targetView });
          } else if (this.normalizeSQL(currentView.sql) !== this.normalizeSQL(targetView.sql)) {
              // Changed -> SQLite doesn't support ALTER VIEW usually, so DROP + CREATE
              viewDiffs.push({ viewName: targetView.name, changeType: "ALTER", oldView: currentView, newView: targetView });
          }
      }
      for (const currentView of currentViews) {
          if (!targetViewMap.has(currentView.name)) {
              viewDiffs.push({ viewName: currentView.name, changeType: "DROP", oldView: currentView });
          }
      }

      // 4. Triggers
      const currentTriggerMap = new Map(currentTriggers.map(t => [t.name, t]));
      const targetTriggerMap = new Map(targetTriggers.map(t => [t.name, t]));
      
      for (const targetTrigger of targetTriggers) {
          const currentTrigger = currentTriggerMap.get(targetTrigger.name);
          if (!currentTrigger) {
              triggerDiffs.push({ triggerName: targetTrigger.name, changeType: "CREATE", newTrigger: targetTrigger });
          } else if (this.normalizeSQL(currentTrigger.sql) !== this.normalizeSQL(targetTrigger.sql)) {
              triggerDiffs.push({ triggerName: targetTrigger.name, changeType: "ALTER", oldTrigger: currentTrigger, newTrigger: targetTrigger });
          }
      }
      for (const currentTrigger of currentTriggers) {
          if (!targetTriggerMap.has(currentTrigger.name)) {
               triggerDiffs.push({ triggerName: currentTrigger.name, changeType: "DROP", oldTrigger: currentTrigger });
          }
      }

      return { tableDiffs, viewDiffs, triggerDiffs };
  }
  
  static normalizeSQL(sql: string): string {
      return sql.replace(/\s+/g, ' ').trim().toLowerCase();
  }

  static compareTable(
    current: TableSchema,
    target: TableSchema,
    columnRenames: Record<string, string> = {} // oldCol -> newCol
  ): TableDiff {
    const columnDiffs: ColumnDiff[] = [];
    const indexDiffs: IndexDiff[] = [];
    
    // Reverse Col Map
    const reverseColRenames = Object.entries(columnRenames).reduce((acc, [old, newName]) => {
        acc[newName] = old;
        return acc;
    }, {} as Record<string, string>);

    // Compare Columns
    const currentCols = new Map(current.columns.map((c) => [c.name, c]));
    
    // Check target columns
    for (const targetCol of target.columns) {
      let currentCol: ColumnDefinition | undefined;
      const oldColName = reverseColRenames[targetCol.name];
      
      if (oldColName) {
          currentCol = currentCols.get(oldColName);
      } else {
          currentCol = currentCols.get(targetCol.name);
      }

      if (!currentCol) {
        columnDiffs.push({
          columnName: targetCol.name,
          changeType: "CREATE",
          newColumn: targetCol,
        });
      } else {
        const differences = this.compareColumnDefinitions(currentCol, targetCol);
        
        let changeType: ChangeType = differences.length > 0 ? "ALTER" : "NONE";
        
        if (oldColName && oldColName !== targetCol.name) {
             changeType = "RENAME";
             // If we also altered type/constraints, it's effectively a Rename + Alter. 
             // In many DBs this is one or two stats.
             // We'll mark it as RENAME here, and let generator handle if it needs extra ALTERs.
             // Usually renaming is `ALTER TABLE x RENAME COLUMN a TO b`. 
             // If type changed, well, SQLite allows type change on Rename? No, separate steps maybe.
        }

        if (changeType !== "NONE") {
          columnDiffs.push({
            columnName: targetCol.name, // The NEW name is what identifies this diff entry generally? Or usually the key.
            // Wait, if we use targetCol.name, generator needs to know old name to rename FROM.
            // We should attach oldColumn info.
            changeType,
            oldColumn: currentCol,
            newColumn: targetCol,
            differences,
          });
        }
      }
    }

    // Check current columns (Drop)
    for (const currentCol of current.columns) {
      // If renamed, skip
      if (columnRenames[currentCol.name]) continue;
      
      const targetHasIt = target.columns.some(c => c.name === currentCol.name);
      if (!targetHasIt) {
        columnDiffs.push({
          columnName: currentCol.name,
          changeType: "DROP",
          oldColumn: currentCol,
        });
      }
    }

    // Compare Indexes
    const currentIndexes = new Map((current.indexes || []).map((i) => [i.name, i]));
    const targetIndexes = new Map((target.indexes || []).map((i) => [i.name, i]));

    // Check target indexes (Create or Alter -> actually Drop + Create for indexes)
    for (const targetIdx of (target.indexes || [])) {
      const currentIdx = currentIndexes.get(targetIdx.name);

      if (!currentIdx) {
        indexDiffs.push({
          indexName: targetIdx.name,
          changeType: "CREATE",
          newIndex: targetIdx,
        });
      } else {
        if (!this.compareIndexDefinitions(currentIdx, targetIdx)) {
            // Indexes are immutable, so we drop and recreate if different
            indexDiffs.push({
                indexName: targetIdx.name,
                changeType: "ALTER",
                oldIndex: currentIdx,
                newIndex: targetIdx
            });
        }
      }
    }

    // Check current indexes (Drop)
    for (const currentIdx of (current.indexes || [])) {
      if (!targetIndexes.has(currentIdx.name)) {
        // Ignore SQLite auto-indexes which are implicit
        if (currentIdx.name.startsWith("sqlite_autoindex_")) continue;
        
        indexDiffs.push({
          indexName: currentIdx.name,
          changeType: "DROP",
          oldIndex: currentIdx,
        });
      }
    }

    let changeType: ChangeType = "NONE";
    if (columnDiffs.length > 0 || indexDiffs.length > 0) {
      changeType = "ALTER";
    }

    return {
      tableName: target.tableName,
      changeType,
      oldSchema: current,
      newSchema: target,
      columnDiffs,
      indexDiffs,
    };
  }

  static compareColumnDefinitions(
    col1: ColumnDefinition,
    col2: ColumnDefinition
  ): string[] {
    const diffs: string[] = [];

    // Normalize types for comparison (e.g. VARCHAR vs TEXT)
    const type1 = this.normalizeType(col1.type);
    const type2 = this.normalizeType(col2.type);

    if (type1 !== type2) diffs.push("type");
    if (!!col1.primaryKey !== !!col2.primaryKey) diffs.push("primaryKey");
    if (!!col1.notNull !== !!col2.notNull) diffs.push("notNull");
    if (!!col1.unique !== !!col2.unique) diffs.push("unique");

    // Default Value Comparison needs care (string vs number vs object)
    if (!this.compareDefaultValues(col1.defaultValue, col2.defaultValue)) {
        diffs.push("defaultValue");
    }

    return diffs;
  }

  static normalizeType(type: string): string {
      const t = type.toUpperCase();
      if (t === 'VARCHAR') return 'TEXT';
      if (t === 'INT') return 'INTEGER';
      if (t === 'BOOL') return 'BOOLEAN';
      return t;
  }

  static compareDefaultValues(val1: any, val2: any): boolean {
    if (val1 === val2) return true;
    if (val1 === undefined && val2 === undefined) return true;
    
    // Normalize string representation
    let s1 = String(val1);
    let s2 = String(val2);

    // Strip surrounding parentheses recursively (SQLite often adds them to expressions)
    // E.g. "CURRENT_TIMESTAMP" vs "(CURRENT_TIMESTAMP)"
    while (s1.startsWith('(') && s1.endsWith(')')) {
        s1 = s1.slice(1, -1);
    }
    while (s2.startsWith('(') && s2.endsWith(')')) {
        s2 = s2.slice(1, -1);
    }
    
    if (s1 === s2) return true;
    
    // Handle Boolean vs Boolean-as-Integer/String (SQLite)
    if ((s1 === "true" && s2 === "1") || (s1 === "1" && s2 === "true")) return true;
    if ((s1 === "false" && s2 === "0") || (s1 === "0" && s2 === "false")) return true;

    // Handle string quoting in defaults if needed
    // e.g. "'val'" vs "val"
    const clean1 = s1.replace(/^'|'$/g, '');
    const clean2 = s2.replace(/^'|'$/g, '');
    if (clean1 === clean2) return true;

    return false;
  }

  static compareIndexDefinitions(
    idx1: { columns: string[]; unique?: boolean },
    idx2: { columns: string[]; unique?: boolean }
  ): boolean {
    if (!!idx1.unique !== !!idx2.unique) return false;
    if (idx1.columns.length !== idx2.columns.length) return false;
    
    // Order matters for indexes
    for (let i = 0; i < idx1.columns.length; i++) {
        if (idx1.columns[i] !== idx2.columns[i]) return false;
    }
    return true;
  }
}
